#!/bin/bash

# Define the start and end colors in HEX (RGB) format
GRAD_START="#FF00FF" # Magenta
GRAD_END="#00FFFF"   # Cyan

# Function to convert HEX to R, G, B
hex_to_rgb() {
    local hex_color="$1"
    local r_hex g_hex b_hex
    r_hex="${hex_color:1:2}"
    g_hex="${hex_color:3:2}"
    b_hex="${hex_color:5:2}"
    printf "%d %d %d" "0x$r_hex" "0x$g_hex" "0x$b_hex"
}

# Function to get an interpolated color given a progress (0.0 to 1.0)
# Arguments: progress (float), start_hex (string), end_hex (string)
get_gradient_color() {
    local progress="$1"
    local start_hex="$2"
    local end_hex="$3"

    # Convert hex to RGB arrays
    read -r start_r start_g start_b <<< $(hex_to_rgb "$start_hex")
    read -r end_r end_g end_b <<< $(hex_to_rgb "$end_hex")

    # Interpolate each color component
    # Use printf %.0f to round to the nearest integer
    local r=$(printf "%.0f" "$(echo "$start_r + ($end_r - $start_r) * $progress" | bc -l)")
    local g=$(printf "%.0f" "$(echo "$start_g + ($end_g - $start_g) * $progress" | bc -l)")
    local b=$(printf "%.0f" "$(echo "$start_b + ($end_b - $start_b) * $progress" | bc -l)")

    # Ensure color values are within 0-255 range
    ((r = r < 0 ? 0 : (r > 255 ? 255 : r)))
    ((g = g < 0 ? 0 : (g > 255 ? 255 : g)))
    ((b = b < 0 ? 0 : (b > 255 ? 255 : b)))

    # Output ANSI truecolor escape sequence
    printf "\x1b[38;2;%d;%d;%dm" "$r" "$g" "$b"
}

# --- Main logic ---

# Read all of stdin into a variable first to get its length
# This allows us to calculate character-specific progress for the gradient.
# Using IFS= read -r -d '' to read the entire stdin including newlines
# and without interpreting backslashes.
IFS= read -r -d '' input_string

# Calculate total length of the input string
total_chars=${#input_string}

# Initialize character counter
char_count=0

# Loop through each character of the input string
# ${input_string:i:1} extracts one character at index i
for (( i=0; i<total_chars; i++ )); do
    char="${input_string:i:1}"

    # Calculate progress for the current character
    # Avoid division by zero if total_chars is 0 or 1
    if (( total_chars <= 1 )); then
        progress=0.0
    else
        progress=$(echo "scale=4; $char_count / ($total_chars - 1)" | bc -l)
    fi

    # Get the ANSI color code for the current character
    color_code=$(get_gradient_color "$progress" "$GRAD_START" "$GRAD_END")

    # Print the character with its interpolated color
    printf "%s%s" "$color_code" "$char"

    # Increment character counter
    ((char_count++))
done

# Reset color at the end
printf "\x1b[0m\n"